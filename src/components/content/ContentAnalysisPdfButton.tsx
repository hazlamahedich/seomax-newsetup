import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { 
  DownloadIcon, 
  FileIcon, 
  Loader2Icon 
} from 'lucide-react';
import { useToast } from '@/components/ui/use-toast';
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';

interface ContentAnalysisPdfButtonProps {
  contentPageId: string;
  contentPage: any;
  analysis: any;
  variant?: 'default' | 'outline' | 'secondary' | 'ghost' | 'link' | 'destructive';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}

export function ContentAnalysisPdfButton({ 
  contentPageId,
  contentPage,
  analysis,
  variant = 'default',
  size = 'default'
}: ContentAnalysisPdfButtonProps) {
  const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
  const { toast } = useToast();
  
  const generatePDF = async () => {
    if (!analysis || !contentPage) {
      toast({
        title: "Error",
        description: "No analysis data available to export",
        variant: "destructive"
      });
      return null;
    }
    
    try {
      setStatus('loading');
      
      // Create a PDF document
      const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'mm',
        format: 'a4',
      });
      
      // Set the document properties
      pdf.setProperties({
        title: `Content Analysis - ${contentPage.title}`,
        subject: `Content Analysis for ${contentPage.url}`,
        author: 'SEOMax',
        keywords: 'Content, analysis, SEO',
        creator: 'SEOMax',
      });
      
      // Add branding and styling
      addBranding(pdf);
      
      // Generate the report content
      await generateReportContent(pdf, contentPage, analysis);
      
      // Save the PDF to a data URL
      const dataUri = pdf.output('datauristring');
      
      setStatus('success');
      return dataUri;
    } catch (error) {
      console.error('Error generating PDF:', error);
      setStatus('error');
      toast({
        title: "PDF Generation Failed",
        description: "Unable to generate PDF for this analysis",
        variant: "destructive"
      });
      return null;
    }
  };
  
  const addBranding = (pdf: jsPDF): void => {
    // Add header
    pdf.setFillColor(51, 65, 85); // slate-700
    pdf.rect(0, 0, 210, 20, 'F');
    
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    pdf.text('SEOMax', 10, 12);
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Content Analysis Report', 50, 12);
    
    // Add footer
    pdf.setFillColor(241, 245, 249); // slate-100
    pdf.rect(0, 287, 210, 10, 'F');
    
    pdf.setDrawColor(203, 213, 225); // slate-300
    pdf.line(0, 287, 210, 287);
    
    pdf.setFontSize(8);
    pdf.setTextColor(100, 116, 139); // slate-500
    pdf.text(`Generated by SEOMax | ${new Date().toLocaleDateString()}`, 10, 293);
    pdf.text(`Page 1`, 180, 293);
  };
  
  const generateReportContent = async (pdf: jsPDF, contentPage: any, analysis: any): Promise<void> => {
    const result = analysis.result;
    
    // Current Y position on the page
    let yPos = 30;
    
    // Report title
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(18);
    pdf.setTextColor(30, 41, 59); // slate-800
    pdf.text(`Content Analysis: ${contentPage.title}`, 10, yPos);
    yPos += 10;
    
    // URL and basic info
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(12);
    pdf.text(`URL: ${contentPage.url}`, 10, yPos);
    yPos += 7;
    
    pdf.setFontSize(10);
    pdf.text(`Date: ${new Date().toLocaleDateString()}`, 10, yPos);
    yPos += 5;
    
    pdf.text(`Overall Score: ${result.content_score} / 100`, 10, yPos);
    yPos += 10;
    
    // Divider
    pdf.setDrawColor(203, 213, 225); // slate-300
    pdf.line(10, yPos, 200, yPos);
    yPos += 10;
    
    // Summary section
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(14);
    pdf.text('Summary', 10, yPos);
    yPos += 8;
    
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(10);
    
    // Add summary text
    const summaryText = [
      `This report provides a comprehensive analysis of the content at ${contentPage.url}.`,
      `Overall Content Score: ${result.content_score}/100`,
      `Analyzed: ${new Date().toLocaleDateString()}`,
      'The following sections break down specific areas for improvement.'
    ];
    
    summaryText.forEach(text => {
      pdf.text(text, 10, yPos);
      yPos += 6;
    });
    
    yPos += 5;
    
    // Add readability analysis
    if (result.readability_analysis) {
      // Check if we need a new page
      if (yPos > 240) {
        pdf.addPage();
        yPos = 30;
      }
      
      // Section title
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(14);
      pdf.text('Readability Analysis', 10, yPos);
      yPos += 10;
      
      // Add readability metrics
      const readability = result.readability_analysis;
      
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Readability Metrics', 10, yPos);
      yPos += 8;
      
      const readabilityMetrics = [
        `Reading Level: ${readability.reading_level}`,
        `Readability Score: ${readability.readability_score}/100`,
        `Sentence Complexity Score: ${readability.sentence_complexity_score}/100`,
        `Vocabulary Score: ${readability.vocabulary_score}/100`
      ];
      
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      
      readabilityMetrics.forEach(metric => {
        pdf.text(metric, 15, yPos);
        yPos += 6;
      });
      
      // Analysis summary
      yPos += 4;
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Analysis', 10, yPos);
      yPos += 8;
      
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      
      // Split long text to fit the page width
      const summaryLines = pdf.splitTextToSize(readability.analysis_summary, 180);
      pdf.text(summaryLines, 15, yPos);
      yPos += (summaryLines.length * 5) + 4;
      
      // Recommendations
      if (readability.recommendations && readability.recommendations.length > 0) {
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.text('Recommendations', 10, yPos);
        yPos += 8;
        
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        
        readability.recommendations.forEach((recommendation: string) => {
          // Add bullet point
          pdf.text('•', 15, yPos);
          
          // Split long text to fit the page width with indent for the bullet
          const recLines = pdf.splitTextToSize(recommendation, 175);
          pdf.text(recLines, 20, yPos);
          yPos += (recLines.length * 5) + 3;
        });
      }
      
      yPos += 5;
    }
    
    // Add keyword analysis
    if (result.keyword_analysis) {
      // Check if we need a new page
      if (yPos > 240) {
        pdf.addPage();
        yPos = 30;
      }
      
      // Section title
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(14);
      pdf.text('Keyword Analysis', 10, yPos);
      yPos += 10;
      
      // Add keyword metrics
      const keywordAnalysis = result.keyword_analysis;
      
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Keyword Metrics', 10, yPos);
      yPos += 8;
      
      const keywordMetrics = [
        `Optimization Score: ${keywordAnalysis.optimization_score}/100`,
        `Natural Usage Score: ${keywordAnalysis.natural_usage_score}/100`
      ];
      
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      
      keywordMetrics.forEach(metric => {
        pdf.text(metric, 15, yPos);
        yPos += 6;
      });
      
      // Keyword placement
      if (keywordAnalysis.keyword_placement) {
        yPos += 4;
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.text('Keyword Placement', 10, yPos);
        yPos += 8;
        
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        
        const placement = keywordAnalysis.keyword_placement;
        const placementText = [
          `Title: ${placement.title ? '✓' : '✗'}`,
          `Headings: ${placement.headings ? '✓' : '✗'}`,
          `Introduction: ${placement.intro ? '✓' : '✗'}`,
          `Body: ${placement.body ? '✓' : '✗'}`,
          `Conclusion: ${placement.conclusion ? '✓' : '✗'}`
        ];
        
        placementText.forEach(text => {
          pdf.text(text, 15, yPos);
          yPos += 6;
        });
      }
      
      // Related Keywords
      if (keywordAnalysis.related_keywords && keywordAnalysis.related_keywords.length > 0) {
        yPos += 4;
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.text('Related Keywords', 10, yPos);
        yPos += 8;
        
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        
        keywordAnalysis.related_keywords.forEach((keyword: string) => {
          pdf.text(`• ${keyword}`, 15, yPos);
          yPos += 6;
        });
      }
      
      // Analysis summary
      yPos += 4;
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Analysis', 10, yPos);
      yPos += 8;
      
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      
      if (keywordAnalysis.analysis_summary) {
        const summaryLines = pdf.splitTextToSize(keywordAnalysis.analysis_summary, 180);
        pdf.text(summaryLines, 15, yPos);
        yPos += (summaryLines.length * 5) + 4;
      }
      
      // Recommendations
      if (keywordAnalysis.recommendations && keywordAnalysis.recommendations.length > 0) {
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.text('Recommendations', 10, yPos);
        yPos += 8;
        
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        
        keywordAnalysis.recommendations.forEach((recommendation: string) => {
          // Add bullet point
          pdf.text('•', 15, yPos);
          
          // Split long text to fit the page width with indent for the bullet
          const recLines = pdf.splitTextToSize(recommendation, 175);
          pdf.text(recLines, 20, yPos);
          yPos += (recLines.length * 5) + 3;
        });
      }
      
      yPos += 5;
    }
    
    // Add structure analysis
    if (result.structure_analysis) {
      // Check if we need a new page
      if (yPos > 240) {
        pdf.addPage();
        yPos = 30;
      }
      
      // Section title
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(14);
      pdf.text('Content Structure Analysis', 10, yPos);
      yPos += 10;
      
      // Add structure metrics
      const structureAnalysis = result.structure_analysis;
      
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Structure Metrics', 10, yPos);
      yPos += 8;
      
      const structureMetrics = [
        `Structure Score: ${structureAnalysis.structure_score}/100`,
        `Formatting Score: ${structureAnalysis.formatting_score}/100`,
        `Organization Score: ${structureAnalysis.organization_score}/100`,
        `Intro/Conclusion Score: ${structureAnalysis.intro_conclusion_score}/100`
      ];
      
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      
      structureMetrics.forEach(metric => {
        pdf.text(metric, 15, yPos);
        yPos += 6;
      });
      
      // Heading hierarchy
      if (structureAnalysis.heading_hierarchy) {
        yPos += 4;
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.text('Heading Structure', 10, yPos);
        yPos += 8;
        
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        
        const hierarchy = structureAnalysis.heading_hierarchy;
        const hierarchyText = [
          `H1 Tags: ${hierarchy.h1_count || 0}`,
          `H2 Tags: ${hierarchy.h2_count || 0}`,
          `H3 Tags: ${hierarchy.h3_count || 0}`,
          `Correct Hierarchy: ${hierarchy.hierarchy_correct ? '✓' : '✗'}`
        ];
        
        hierarchyText.forEach(text => {
          pdf.text(text, 15, yPos);
          yPos += 6;
        });
      }
      
      // Content gaps
      if (structureAnalysis.content_gaps && structureAnalysis.content_gaps.length > 0) {
        yPos += 4;
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.text('Content Gaps', 10, yPos);
        yPos += 8;
        
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        
        structureAnalysis.content_gaps.forEach((gap: string) => {
          pdf.text(`• ${gap}`, 15, yPos);
          yPos += 6;
        });
      }
      
      // Analysis summary
      yPos += 4;
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(12);
      pdf.text('Analysis', 10, yPos);
      yPos += 8;
      
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      
      if (structureAnalysis.analysis_summary) {
        const summaryLines = pdf.splitTextToSize(structureAnalysis.analysis_summary, 180);
        pdf.text(summaryLines, 15, yPos);
        yPos += (summaryLines.length * 5) + 4;
      }
      
      // Recommendations
      if (structureAnalysis.recommendations && structureAnalysis.recommendations.length > 0) {
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.text('Recommendations', 10, yPos);
        yPos += 8;
        
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        
        structureAnalysis.recommendations.forEach((recommendation: string) => {
          // Add bullet point
          pdf.text('•', 15, yPos);
          
          // Split long text to fit the page width with indent for the bullet
          const recLines = pdf.splitTextToSize(recommendation, 175);
          pdf.text(recLines, 20, yPos);
          yPos += (recLines.length * 5) + 3;
        });
      }
    }
    
    // Add overall recommendations section
    if (result.recommendations && result.recommendations.length > 0) {
      // Check if we need a new page
      if (yPos > 240) {
        pdf.addPage();
        yPos = 30;
      }
      
      // Section title
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(14);
      pdf.text('Overall Recommendations', 10, yPos);
      yPos += 10;
      
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(10);
      
      result.recommendations.forEach((recommendation: string) => {
        // Add bullet point
        pdf.text('•', 15, yPos);
        
        // Split long text to fit the page width with indent for the bullet
        const recLines = pdf.splitTextToSize(recommendation, 175);
        pdf.text(recLines, 20, yPos);
        yPos += (recLines.length * 5) + 3;
      });
    }
    
    // Conclusion
    if (yPos > 240) {
      pdf.addPage();
      yPos = 30;
    }
    
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(14);
    pdf.text('Conclusion', 10, yPos);
    yPos += 8;
    
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(10);
    
    const conclusionText = [
      `Based on our analysis, your content has received an overall score of ${result.content_score}/100.`,
      'We recommend implementing the suggestions provided in this report to improve your content\'s performance.',
      'For additional assistance with content optimization, contact our support team.',
      '',
      'Thank you for using SEOMax for your content analysis.'
    ];
    
    conclusionText.forEach(text => {
      pdf.text(text, 10, yPos);
      yPos += 6;
    });
    
    // Update page numbers in footer
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      
      pdf.setFillColor(241, 245, 249); // slate-100
      pdf.rect(0, 287, 210, 10, 'F');
      
      pdf.setDrawColor(203, 213, 225); // slate-300
      pdf.line(0, 287, 210, 287);
      
      pdf.setFontSize(8);
      pdf.setTextColor(100, 116, 139); // slate-500
      pdf.text(`Generated by SEOMax | ${new Date().toLocaleDateString()}`, 10, 293);
      pdf.text(`Page ${i} of ${totalPages}`, 180, 293);
    }
  };
  
  const handleClick = async () => {
    try {
      setStatus('loading');
      const dataUri = await generatePDF();
      
      if (!dataUri) {
        setStatus('error');
        return;
      }
      
      // Create safe filename from content page title
      const filename = contentPage 
        ? `content-analysis-${contentPage.title.replace(/[^a-z0-9]/gi, '-').toLowerCase()}.pdf`
        : `content-analysis-${contentPageId}.pdf`;
      
      // Create an invisible link and trigger download
      const link = document.createElement('a');
      link.href = dataUri;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      toast({
        title: "Success",
        description: "PDF downloaded successfully",
      });
      
      setStatus('success');
    } catch (error) {
      console.error('Error downloading PDF:', error);
      toast({
        title: "Download Failed",
        description: "Failed to download the PDF",
        variant: "destructive"
      });
      
      setStatus('error');
    }
  };
  
  const isLoading = status === 'loading';
  const isAvailable = Boolean(analysis?.result);
  
  return (
    <Button
      variant={variant}
      size={size}
      onClick={handleClick}
      disabled={isLoading || !isAvailable}
    >
      {isLoading ? (
        <>
          <Loader2Icon className="mr-2 h-4 w-4 animate-spin" />
          Generating...
        </>
      ) : (
        <>
          <DownloadIcon className="mr-2 h-4 w-4" />
          Export PDF
        </>
      )}
    </Button>
  );
} 