import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { SEOAuditReport, SEOAuditCategoryScore } from '@/lib/store/seo-audit-store';

export class PDFGenerationService {
  /**
   * Generates a PDF from a report object
   * @param report The SEO audit report to generate a PDF for
   * @returns A Promise resolving to the PDF as a data URL
   */
  static async generatePDF(report: SEOAuditReport): Promise<string> {
    // Create a new document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
    });
    
    // Set the document properties
    pdf.setProperties({
      title: `SEO Audit - ${report.name}`,
      subject: `SEO Audit Report for ${report.url}`,
      author: 'SEOMax',
      keywords: 'SEO, audit, report',
      creator: 'SEOMax',
    });
    
    // Add branding and styling
    this.addBranding(pdf);
    
    // Generate the report content
    await this.generateReportContent(pdf, report);
    
    // Save the PDF to a data URL
    const dataUri = pdf.output('datauristring');
    return dataUri;
  }
  
  /**
   * Add branding elements to the PDF
   * @param pdf The PDF document
   */
  private static addBranding(pdf: jsPDF): void {
    // Add header
    pdf.setFillColor(51, 65, 85); // slate-700
    pdf.rect(0, 0, 210, 20, 'F');
    
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    pdf.text('SEOMax', 10, 12);
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Professional SEO Audit Report', 50, 12);
    
    // Add footer to all pages
    const totalPages = pdf.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      
      pdf.setFillColor(241, 245, 249); // slate-100
      pdf.rect(0, 287, 210, 10, 'F');
      
      pdf.setDrawColor(203, 213, 225); // slate-300
      pdf.line(0, 287, 210, 287);
      
      pdf.setFontSize(8);
      pdf.setTextColor(100, 116, 139); // slate-500
      pdf.text(`Generated by SEOMax | ${new Date().toLocaleDateString()}`, 10, 293);
      pdf.text(`Page ${i} of ${totalPages}`, 180, 293);
    }
  }
  
  /**
   * Generate the main content of the report
   * @param pdf The PDF document
   * @param report The SEO audit report data
   */
  private static async generateReportContent(pdf: jsPDF, report: SEOAuditReport): Promise<void> {
    // Current Y position on the page
    let yPos = 30;
    
    // Report title
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(18);
    pdf.setTextColor(30, 41, 59); // slate-800
    pdf.text(`SEO Audit: ${report.name}`, 10, yPos);
    yPos += 10;
    
    // URL and basic info
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(12);
    pdf.text(`URL: ${report.url}`, 10, yPos);
    yPos += 7;
    
    pdf.setFontSize(10);
    pdf.text(`Date: ${new Date(report.createdAt).toLocaleDateString()}`, 10, yPos);
    yPos += 5;
    
    pdf.text(`Overall Score: ${report.overallScore} / 100 (${report.overallGrade})`, 10, yPos);
    yPos += 10;
    
    // Divider
    pdf.setDrawColor(203, 213, 225); // slate-300
    pdf.line(10, yPos, 200, yPos);
    yPos += 10;
    
    // Summary section
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(14);
    pdf.text('Summary', 10, yPos);
    yPos += 8;
    
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(10);
    
    // Calculate total issues
    const totalIssues = report.categories?.reduce(
      (sum: number, category: SEOAuditCategoryScore) => sum + (category.issuesCount || 0),
      0
    ) || 0;
    
    const summaryText = [
      `This report provides a comprehensive analysis of the SEO health of ${report.url}.`,
      `Overall Score: ${report.overallScore}/100 (${report.overallGrade})`,
      `Total Issues Found: ${totalIssues}`,
      'The following sections break down specific areas for improvement.',
    ];
    
    // Add summary text
    summaryText.forEach(text => {
      pdf.text(text, 10, yPos);
      yPos += 6;
    });
    
    yPos += 5;
    
    // Category scores
    if (report.categories && report.categories.length > 0) {
      // Section title
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(14);
      pdf.text('Category Scores', 10, yPos);
      yPos += 10;
      
      // Draw table header
      this.drawCategoryTableHeader(pdf, yPos);
      yPos += 8;
      
      // Draw categories
      for (const category of report.categories) {
        this.drawCategoryRow(pdf, yPos, category);
        yPos += 8;
        
        // Check if we need a new page
        if (yPos > 260) {
          pdf.addPage();
          yPos = 30;
          this.drawCategoryTableHeader(pdf, yPos);
          yPos += 8;
        }
      }
      
      yPos += 10;
    }
    
    // Add recommendations
    if (report.recommendations && report.recommendations.length > 0) {
      // Check if we need a new page
      if (yPos > 240) {
        pdf.addPage();
        yPos = 30;
      }
      
      // Section title
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(14);
      pdf.text('Recommendations', 10, yPos);
      yPos += 10;
      
      // Process each category of recommendations
      for (const category of report.recommendations) {
        // Category heading
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        
        // Add priority label if available
        let categoryText = category.category;
        if (category.priority) {
          const priorityLabel = category.priority.charAt(0).toUpperCase() + category.priority.slice(1);
          categoryText = `${categoryText} (${priorityLabel} Priority)`;
        }
        
        pdf.text(categoryText, 10, yPos);
        yPos += 8;
        
        // Recommendations
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        
        for (const recommendation of category.recommendations) {
          // Handle multi-line text with proper wrapping
          const splitText = pdf.splitTextToSize(recommendation, 180);
          
          // Check if we need to add a new page
          if (yPos + (splitText.length * 5) > 270) {
            pdf.addPage();
            yPos = 30;
          }
          
          // Add a bullet point and the recommendation text
          pdf.text('â€¢', 12, yPos);
          pdf.text(splitText, 16, yPos);
          
          // Increase yPos based on number of lines
          yPos += (splitText.length * 5) + 3;
        }
        
        yPos += 5;
        
        // Check if we need a new page for the next category
        if (yPos > 260 && report.recommendations.indexOf(category) < report.recommendations.length - 1) {
          pdf.addPage();
          yPos = 30;
        }
      }
    }
    
    // Add technical issues if available
    if (report.technicalIssues && report.technicalIssues.length > 0) {
      // Check if we need a new page
      if (yPos > 240) {
        pdf.addPage();
        yPos = 30;
      }
      
      // Section title
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(14);
      pdf.text('Technical Issues', 10, yPos);
      yPos += 10;
      
      // Process each category of technical issues
      for (const category of report.technicalIssues) {
        // Category heading
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(12);
        pdf.text(category.name, 10, yPos);
        yPos += 8;
        
        // Issues
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(10);
        
        for (const issue of category.issues) {
          // Check if we need to add a new page
          if (yPos > 260) {
            pdf.addPage();
            yPos = 30;
          }
          
          // Issue title with severity
          const severityColor = this.getSeverityColor(issue.severity);
          pdf.setTextColor(severityColor.r, severityColor.g, severityColor.b);
          pdf.setFont('helvetica', 'bold');
          pdf.text(`[${issue.severity.toUpperCase()}] ${issue.title}`, 12, yPos);
          yPos += 5;
          
          // Reset text color for description
          pdf.setTextColor(30, 41, 59); // slate-800
          pdf.setFont('helvetica', 'normal');
          
          // Handle multi-line text with proper wrapping
          const splitDesc = pdf.splitTextToSize(issue.description, 180);
          pdf.text(splitDesc, 12, yPos);
          
          // Increase yPos based on number of lines
          yPos += (splitDesc.length * 5) + 3;
          
          // Add issue URL if available
          if (issue.url) {
            pdf.setTextColor(59, 130, 246); // blue-500
            pdf.text(`URL: ${issue.url}`, 12, yPos);
            pdf.setTextColor(30, 41, 59); // Reset to slate-800
            yPos += 5;
          }
          
          yPos += 3;
        }
        
        yPos += 5;
        
        // Check if we need a new page for the next category
        if (yPos > 260 && report.technicalIssues.indexOf(category) < report.technicalIssues.length - 1) {
          pdf.addPage();
          yPos = 30;
        }
      }
    }
    
    // Conclusion
    if (yPos > 240) {
      pdf.addPage();
      yPos = 30;
    }
    
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(14);
    pdf.text('Conclusion', 10, yPos);
    yPos += 8;
    
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(10);
    
    const conclusionText = [
      `Based on our analysis, your website has received an overall score of ${report.overallScore}/100 (${report.overallGrade}).`,
      'We recommend addressing the issues highlighted in this report to improve your website\'s SEO performance.',
      'For technical assistance with implementing these recommendations, please contact our support team.',
      '',
      'Thank you for using SEOMax for your SEO audit needs.',
    ];
    
    conclusionText.forEach(text => {
      pdf.text(text, 10, yPos);
      yPos += 6;
    });
  }
  
  /**
   * Draw the category table header
   * @param pdf The PDF document
   * @param yPos The Y position
   */
  private static drawCategoryTableHeader(pdf: jsPDF, yPos: number): void {
    // Background
    pdf.setFillColor(241, 245, 249); // slate-100
    pdf.rect(10, yPos - 6, 190, 8, 'F');
    
    // Header text
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(10);
    pdf.setTextColor(30, 41, 59); // slate-800
    
    // Column positions
    pdf.text('Category', 12, yPos);
    pdf.text('Score', 110, yPos);
    pdf.text('Grade', 140, yPos);
    pdf.text('Issues', 170, yPos);
    
    // Bottom border
    pdf.setDrawColor(203, 213, 225); // slate-300
    pdf.line(10, yPos + 2, 200, yPos + 2);
  }
  
  /**
   * Draw a category row in the table
   * @param pdf The PDF document
   * @param yPos The Y position
   * @param category The category data
   */
  private static drawCategoryRow(pdf: jsPDF, yPos: number, category: SEOAuditCategoryScore): void {
    // Row text
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(10);
    pdf.setTextColor(30, 41, 59); // slate-800
    
    // Category name, truncate if too long
    let catName = category.categoryName;
    if (catName.length > 40) {
      catName = catName.substring(0, 37) + '...';
    }
    pdf.text(catName, 12, yPos);
    
    // Score with color based on value
    const scoreColor = this.getScoreColor(category.score);
    pdf.setTextColor(scoreColor.r, scoreColor.g, scoreColor.b);
    pdf.text(category.score.toString(), 110, yPos);
    
    // Grade
    pdf.text(category.grade, 140, yPos);
    
    // Issues count
    pdf.setTextColor(30, 41, 59); // Reset to slate-800
    pdf.text(category.issuesCount.toString(), 170, yPos);
    
    // Bottom border
    pdf.setDrawColor(229, 231, 235); // gray-200
    pdf.line(10, yPos + 2, 200, yPos + 2);
  }
  
  /**
   * Get color for a score value
   * @param score The score (0-100)
   * @returns RGB color object
   */
  private static getScoreColor(score: number): { r: number, g: number, b: number } {
    if (score >= 90) return { r: 34, g: 197, b: 94 }; // green-500
    if (score >= 70) return { r: 59, g: 130, b: 246 }; // blue-500
    if (score >= 50) return { r: 245, g: 158, b: 11 }; // amber-500
    return { r: 239, g: 68, b: 68 }; // red-500
  }
  
  /**
   * Get color for a severity level
   * @param severity The severity (high, medium, low)
   * @returns RGB color object
   */
  private static getSeverityColor(severity: string): { r: number, g: number, b: number } {
    switch (severity.toLowerCase()) {
      case 'high':
        return { r: 239, g: 68, b: 68 }; // red-500
      case 'medium':
        return { r: 245, g: 158, b: 11 }; // amber-500
      case 'low':
        return { r: 59, g: 130, b: 246 }; // blue-500
      default:
        return { r: 30, g: 41, b: 59 }; // slate-800
    }
  }
} 